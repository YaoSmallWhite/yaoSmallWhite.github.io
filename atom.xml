<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>平凡之路</title>
  
  <subtitle>Yao的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-22T03:02:32.059Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Henry Yao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>物联网基础知识</title>
    <link href="http://yoursite.com/2019/02/22/%E7%89%A9%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/02/22/物联网基础知识/</id>
    <published>2019-02-22T03:01:32.000Z</published>
    <updated>2019-02-22T03:02:32.059Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.hacpai.com/bing/20180612.jpg?imageView2/1/w/960/h/520/interlace/1/q/100" alt=""></p><p>整体结构</p><p>物联网大体上有 3 个构成要素，如图 2.1 所示。一个是设备，另一个是网关，再来就是服务器。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.001.png" alt=""></p><p>图 2.1　物联网的整体结构</p><p>2.1.2　网关</p><p>如图 2.1 左下所示，物联网使用的设备中，有 3 台设备不能直接连接到互联网。网关就负责把这些设备转发到互联网。</p><p>网关指的是能连接多台设备，并具备直接连接到互联网的功能的机器和软件（图 2.2）。如今，市面上有很多种网关。在多数情况下，网关凭借 Linux 操作系统来运行。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.002.png" alt=""></p><p>图 2.2　选择网关的标准</p><p>选择网关时有几项重要的标准，我们来一起看一下。</p><p>◉ 接口</p><p>第一重要的是用于连接网关和设备的接口。网关的接口决定了能连接的设备，因此重点在于选择一个适配设备的接口。</p><p>有线连接方式包括串行通信和 USB 连接。串行通信中经常用的是一种叫作 D-SUB 9 针（pin）的连接器，而 USB 连接中用到的 USB 连接器则种类繁多。</p><p>无线连接中用的接口是蓝牙和 Wi-Fi（IEEE 802.11）。此外，还有采用 920 MHz 频段的 Zigbee 标准，以及各制造商们的专属协议。第 3 章会详细讲解这些规格各自的特征，重点在于根据设备对应的标准来选择接口。</p><p>◉ 网络接口</p><p>我们用以太网或是 Wi-Fi、3G/LTE 来连接外部网络。网络接口会影响到网关的设置场所。以太网采用有线连接，通信环境稳定。然而正因为采用的是有线连接，所以必须把 LAN 电缆布线到网关的设置场所。因此，在设置场所方面就会在某种程度上受到限制。</p><p>对 3G/LTE 连接而言，设置场所就比较自由了，但通信的质量会受信号强弱影响，所以通信不如有线连接稳定。因此，有时很难在信号不良的大楼和工厂等封闭环境中设置。不过，3G/LTE 连接有个好处，即只使用网关就能完成和外部的通信，因此操作起来很简单。此外，想使用 3G/LTE 时，需要和电信运营商签订协议并获取 SIM 卡，这点就跟使用手机一样。</p><p>网关的作用</p><p>就如我们前面说的那样，网关是一台用于把不能直接连接到互联网的设备转发连接到互联网的设备。再往细了说，网关是由 3 种功能构成的（图 2.4）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.004.png" alt=""></p><p>图 2.4　网关的功能</p><p>2.1.3　服务器的结构</p><p>在功能方面，物联网服务大体上可分为 3 个部分，本书分别称它们为前端部分、处理部分，以及数据库部分（图 2.3）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.003.png" alt=""></p><p>图 2.3　物联网服务的 3 个功能</p><p>首先，前端部分包括数据接收服务器和数据发送服务器。数据接收服务器接收设备和网关发来的数据，转交给后续的处理部分。数据发送服务器则刚好相反，它负责把从处理服务器接收到的内容发送给设备。</p><p>通常情况下，Web 服务的前端部分只接受 HTTP 协议。而物联网服务的前端部分则需要根据连接设备的不同来匹配 HTTP 以外的协议。使用者需要考虑到协议的实时性和通信的轻量化，以及能否以服务器为起点发送数据。我们会在 2.2 节重新讲解这些协议。</p><p>处理部分负责处理从前端部分接收到的数据。这里的“处理”指的是分解数据、存储数据、分析数据、生成发给设备的通知内容，等等。数据处理包括批处理和流处理等，批处理即把数据存入数据库之后一并进行处理，而流处理是逐次处理从前端部分收到的数据。使用者需要根据处理内容和数据特性来灵活使用这些“处理”。</p><p>最后是数据库。这里的数据库不只会用到关系数据库，还会用到 NoSQL 数据库。当然，使用者需要根据想存储的数据和想使用的方法来选择数据库。</p><p>2.3.1　HTTP 协议</p><p>HTTP 协议提供的是最大众化且最简易的方法。使用一般的 Web 框架就可以制作数据接收服务器。设备用 HTTP 的 GET 方法和 POST 方法访问服务器，把数据存入请求参数和 BODY 并发送（图 2.6）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.006.png" alt=""></p><p>图 2.6　通过 HTTP 协议发送和接收数据</p><p>HTTP 协议是 Web 的标准协议，这一点自不用说。因此 HTTP 协议和 Web 的兼容性非常强。此外，因为 HTTP 协议有非常多的技术诀窍，所以我们必须在制作实际系统时审视服务器的结构，应用程序的架构以及安全性等。关于这点，有很多事例值得参考。另外，HTTP 协议还准备了 OSS 的框架，方便人们使用。</p><p>2.3.3　WebSocket</p><p>WebSocket 是一种通信协议，用于在互联网上实现套接字通信。它实现了 Web 浏览器和 Web 服务器间的数据双向连续传输。</p><p>就 HTTP 协议而言，每次发送数据都必须生成发送数据用的通信路径及连接。此外，一般情况下，客户端没有发出申请就不能进行通信。</p><p>相对而言，WebSocket 就不同了。只要一开始根据客户端发出的连接申请确立了连接，就能持续用同一个连接传输数据。另外，只要确立了连接，就算客户端没有发出申请，服务器也能给客户端发送数据（图 2.7）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.007.png" alt=""></p><p>图 2.7　通过 WebSocket 协议传输数据</p><p>这样一来，在发送语音数据等连续的数据，以及发生与服务器的相互交换时，就能使用 WebSocket 了。WebSocket 自身只提供服务器与客户端的数据交换，因此需要使用者另外决定在应用层上使用的协议。</p><p>2.3.4　MQTT</p><p>MQTT（MQ Telemetry Transport，消息队列遥测传输）是近年来出现的一种新型协议，物联网领域会将其作为标准协议。MQTT 原本是 IBM 公司开发的协议，现在则开源了，被人们不断开发着。</p><p>MQTT 是一种能实现一对多通信（人们称之为发布或订阅型）的协议。它由 3 种功能构成，分别是中介（broker）、发布者（publisher）和订阅者（subscriber）（图 2.8）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.008.png" alt=""></p><p>图 2.8　通过 MQTT 传输消息</p><p>◉ QoS</p><p>QoS 是 Quality of Service（服务质量）的简称。这个词在网络领域表示的是通信线路的品质保证。MQTT 里存在 3 个等级的 QoS。“发布者和中介之间”以及“中介和订阅者之间”都分别定义了不同的 QoS 等级，以异步的方式运行。此外，当“中介与订阅者之间”指定的 QoS 小于“发布者和中介之间”交换的 QoS 时，“中介与订阅者之间”的 QoS 会被降级到指定的 QoS。QoS 0 指的是最多发送一次消息（at most once）（图 2.11），发送要遵循 TCP/IP 通信的“尽力服务”。消息分两种情况，即到达了一次中介处，或没有到达中介处。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.011.png" alt=""></p><p>图 2.11　QoS 0（最多只能发送一次）</p><p>接下来的 QoS 1 是至少发送一次消息（at least once）（图 2.12）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.012.png" alt=""></p><p>图 2.12　QoS 1（至少发送一次消息）</p><p>中介一接收到消息就会向发布者发送一个叫作“PUBACK 消息”的响应，除此之外还会根据订阅者指定的 QoS 发送消息。当发生故障，或经过一定时间后仍没能确认 PUBACK 消息时，发布者会重新发送消息。如果中介接收了发布者发来的消息却没有返回 PUBACK，那么中介会重复收到消息。</p><p>最后是 QoS 2，它指的是准确发送一次消息（exactly once）。把它跟 QoS 1 合在一起使用，就能避免接收到重复的消息（图 2.13）。用 QoS 2 发送的消息里面含有消息 ID。中介收到消息后会将消息保存，然后给发布者发送 PUBREC 消息。发布者再给中介发送 PUBREL 消息，然后中介会给发布者发送 PUBCOMP 消息。接下来中介才会依据订阅者指定的 QoS，向订阅者传递接收到的消息。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.013.png" alt=""></p><p>图 2.13　QoS 2（只发送一次消息）</p><p>此外，就 QoS 2 而言，有时使用的中介会影响消息的传递时间。</p><p>人们通常使用的是 QoS 0，只有要确保信息发送成功时才使用 QoS 1 和 QoS 2，这样一来可以减少网络的负担。后文将会讲到 Clean session，其中 QoS 的设定也是非常重要的。</p><p>◉ Retain</p><p>订阅者只能接收在订阅之后发布的消息，但如果发布者事先发布了带有 Retain 标志的消息，那么订阅者就能在订阅后马上收到消息。</p><p>当发布者发布了带有 Retain 标志的消息时，中介会把消息传递给订阅了主题的订阅者，同时保存带有 Retain 标志的最新的消息。此时，若别的订阅者订阅了主题，就能马上收到带有 Retain 标志的新消息（图 2.14）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.014.png" alt=""></p><p>图 2.14　Retain</p><p>◉ Will</p><p>Will 有“遗言”的意思。由于中介的 I/O 错误或网络故障等情况，发布者可能会突然从中介断开，Will 就是专门针对于这种情况的一个机构，它用于定义中介向订阅者发送的消息（图 2.15）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.015.png" alt=""></p><p>图 2.15　Will</p><p>发布者在连接中介时会用到 CONNECT（连接）消息，连接时对其指定 Will 标志、要发送的消息以及 QoS。这样一来，如果连接意外断开，Will 消息就会被传递给订阅者。另外，还有一个标志叫作 Will Retain。通过指定这个标志，就能跟前面说的 Retain 达到同样的效果，即在中介处保存消息。</p><p>当发布者使用 DISCONNECT（断开连接）消息明确表明连接已断开时，Will 消息就不会被发送给订阅者。</p><p>◉ Clean session</p><p>Clean session 用于指定中介是否保留了订阅者的已订阅状态。用 CONNECT 消息连接时，订阅者把 Clean session 标志设定为 0 或 1。0 是保留 session，1 是不保留 session。</p><p>若指定 Clean session 为 0 且中介已经连接上了订阅者，则中介需要在订阅者断开连接后保留订阅的消息。另外，如果订阅者的连接已经断开，且发布者已经发布了 QoS 1、QoS 2 的消息给已订阅的主题时，中介则会把消息保存，等订阅者再次连接时发送给订阅者（图 2.16）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.016.png" alt=""></p><p>图 2.16　Clean session</p><p>若指定 Clean session 为 1 并连接，中介就会废弃以往保留的客户端信息，将其当成一次“干净”的连接来看待。此外，订阅者断开连接时，中介也会废弃所有的信息。</p><p>我们可以用表 2.1 所示的几种产品来实现 MQTT。是否支持前文介绍的功能则取决于中介的种类。</p><p>表 2.1　MQTT 的实现<br><img src="http://47.101.195.32/upload/7a8b3ba9119d40d28927b2ea13742611_image.png" alt="imagepng"></p><p>除此之外，一个叫作 Paho 的库还公开了发布者和订阅者等客户端功能。不仅 Java、JavaScript、Python 配备了 Paho，连 C 语言和 C++ 都配备了 Paho。因此，我们能够将其与设备结合起来并加以使用。</p><p>数据格式</p><p>前面我们围绕用于接收数据的通信过程，即协议进行了讲解。事实上，数据就是通过协议来进行交换的。当然，就如我们前文所说，这条规则在物联网的世界里也是不变的。数据要经过协议进行交换，而数据的格式也很重要。通过 Web 协议来使用的数据格式中，具有代表性的包括 XML 和 JSON（图 2.17）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.017.png" alt=""></p><p>数据处理</p><p>很显然，处理服务器就是处理接收到的数据的地方。“处理”是一个抽象的词语，例如保存数据，以及转换数据以使其看上去更易懂，还有从多台传感器的数据中发现新的数据，这些都是处理。使用者的目的不同，处理服务器的内容也各异。不过说到数据的处理方法，它可以归纳成以下 4 种：数据分析、数据加工、数据保存以及向设备发出指令（图 2.20）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.020.png" alt=""></p><p>图 2.20　数据的处理</p><p>关于数据的分析和加工，有两种典型的处理方式，分别叫作“批处理”和“流处理”。首先就来说说这个“批处理”和“流处理”。</p><p>批处理</p><p>◉ Apache Hadoop</p><p>Apache Hadoop 是一个对大规模数据进行分布式处理的开源框架。Hadoop 有一种叫作 MapReduce 的机制，用来高效处理数据。MapReduce 是一种专门用于在分布式环境下高效处理数据的机制，它基本由 Map、Shuffle、Reduce 这 3 种处理构成（图 2.21）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.021.png" alt=""></p><p>图 2.21　通过 Hadoop MapReduce 执行批处理</p><p>◉ Apache Spark</p><p>Apache Spark 也和 Hadoop 一样，是一个分布式处理大规模数据的开源框架。Spark 用一种叫作 RDD（Resilient Distributed Dataset，弹性分布数据集）的数据结构来处理数据（图 2.22）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.022.png" alt=""></p><p>图 2.22　通过 Spark 执行批处理</p><p>　流处理</p><p>批处理是把数据攒起来，一次性进行处理的方法。相对而言，流处理是不保存数据，按照到达处理服务器的顺序对数据依次进行处理。</p><p>想实时对数据做出反应时，流处理是一个很有效的处理方法。因为批处理是把数据积攒之后隔一段时间进行处理，所以从数据到达之后到处理完毕为止，会出现时间延迟。因此，流处理这种把到达的数据逐次进行处理的思路就变得很重要了。此外，流处理基本上是不会保存数据的。只要是被使用过的数据，如果没必要保存，就会直接丢弃。</p><p>◉ Spark Streaming</p><p>Spark Streaming 是作为 Apache Spark（在“批处理”部分介绍过）的库被公开的。通过 Spark Streaming，就能够把 Apache Spark 拿到流处理中来使用（图 2.23）。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.023.png" alt=""></p><p>图 2.23　通过 Spark Streaming 执行流处理</p><p>◉ Apache Storm</p><p>Apache Storm 是用于实现流处理的框架，结构如图 2.24 所示。</p><p><img src="http://www1.ituring.com.cn/figures/2017/IOT/04.d02z.024.png" alt=""></p><p><img src="http://www.elecfans.com/uploads/allimg/180416/0Q2024094_0.png" alt=""></p><p>本文思维导图概览</p><p>物联网的基本架构包括三个层面：感知层、网络层和应用层。</p><p><img src="http://www.elecfans.com/uploads/allimg/180416/0Q30115D_0.png" alt=""></p><p>物联网架构图</p><p>物联网架构图</p><p>感知层通过传感器采集某些数据(声、光、电等)，基于网络层的终端模组，对接到网络层的基站，实现数据采集后的传输。</p><p>网络层负责将感知层采集的数据进行回传，基于不同特点采用不同的通信协议技术进行回传至关重要，这也是本文重点所讨论的内容。</p><p>应用层可以理解为物联网的数据平台和业务平台。数据平台作为所有物联网终端数据的集合点，负责数据的统一存储、分析等，北向通过标准的API接口提供给业务平台做数据调用;业务平台基于数据平台的原始数据实现各种业务逻辑，对外呈现的是服务。</p><p>其中，聚焦于网络层的通信协议，则是群雄逐鹿，百家争鸣。</p><p>当下最流行的Wi-Fi技术数据传输速度飞快，尤其802.11ax技术即将诞生，理论上8条流不是梦。然而伴随速度的提升，耗电量急剧增大，且传输距离也成为难题，长距离传输需要每隔一定距离放一个AP进行桥接，这必将大幅提升成本。因此，Wi-Fi技术更适合供PC及PDA等终端应用的室内无线上网场景。</p><p>蓝牙技术与Wi-Fi在2.4G频段上有交接，所以同频段会有一些干扰问题的产生。蓝牙的耗电情况比Wi-Fi稍微低一些， 而传输速度远不及Wi-Fi。在资产追踪、定位标签以及医疗传感器等场景下应用较多，如智能手表，蓝牙定位等。</p><p>Zigbee技术的功耗比较小，通信距离也比较短，是一种短距离低功耗的技术，主要应用于无线传感器及医疗场景等。</p><p>UWB超宽带技术频段较为干净，没有其他频段的干扰，在高精度定位的场景下应用更多。</p><p><img src="http://www.elecfans.com/uploads/allimg/180416/0Q401C19_0.png" alt=""></p><p>通信协议对比</p><p>以上技术更适合近距离场景的数据传输，那么在远距离场景下又有哪些技术呢?</p><p>运营商提供的4G网络，是人们生活中应用最多的，甚至超过Wi-Fi。它可以做到长距离传输，无论在室内还是室外，速度都很可观。这种技术看起来很优越，但其功耗较大，只能应用于终端可自取电的物联网场景，如某公司的共享单车，利用太阳能电池板进行取电。</p><p>在远距离场景下，如果终端不能解决供电问题，那么需要一种具有更低功耗，覆盖范围更大的技术来满足这个场景下的物联网通信需求。于是在业务和技术的驱动下，一些专家和企业为了解决这个问题，研究出一种新型的通信技术——LPWAN，即低功耗广域网技术。</p><p>LPWAN的目标是为物联网应用中的M2M(设备到设备)通信场景而优化的远距离无线网络通讯技术。LPWAN技术的优势主要体现在：低速率、超低功耗、长距离、低吞吐、强覆盖。这些特点恰好说明，此项技术正是针对物联网在长距离传输的场景下开发的。具体应用如：城区覆盖、远程抄表、井盖检测以及近海渔船检测等。</p><p><img src="http://www.elecfans.com/uploads/allimg/180416/0Q501W37_0.png" alt=""></p><p>LPWAN技术特点</p><p>LPWAN作为一个新的技术阵营，其内部分为两大派系：授权频段和非授权频段。授权频段又分为EC-GSM、eMTC以及NB-IoT;而非授权频段的“头牌”则是LoRa。</p><p>　EC-GSM</p><p>随着LPWAN的兴起，传统的GRPS应用于物联网的劣势愈发明显。2014年，3GPP研究项目提出，将窄带(200kHz)物联网技术迁移到GSM上，寻求比传统GPRS高20dB的更广的覆盖范围，并提出五大目标：提升室内覆盖性能、支持大规模设备连接、减小设备复杂性、减小功耗和时延。到了2015年，TSG GERAN #67会议报告表示，EC-GSM已满足5大目标。但随着R13 NB-IoT标准冻结之后，人们将更多精力投入到了重新定义的标准当中。</p><p>eMTC</p><p>eMTC的概念在R13中被正式命名，以前的R12被称为Low-Cost MTC，它是基于LTE演进的物联网技术。eMTC基于蜂窝网进行部署，用户设备通过支持1.4MHz的射频和基带带宽，可直接接入现有的LTE网络。eMTC的关键能力在于速率高(相较于GPRS、zigbee等)、可移动、可定位以及支持语音。。</p><p>　NB-IoT</p><p>最近特别火热的NB-IoT其实是NB-CIoT和NB-LTE两者的融合。NB-CIoT提出了全新的空口技术，较传统LTE网络改动较大，他满足于TSG GERAN#67会议上提出的五大目标，其亮点在于通信模块成本低于GSM及NB-LTE的模块。而NB-LTE则与现有的LTE兼容，特点是利于部署。在激烈的争论后，终于对两者加以融合，形成了NB-IoT的技术标准。</p><p>NB-IoT全称为窄带物联网，可以直接部署于LTE网络，良好的兼容性降低了部署的成本。其本身具有更低的功耗，理论上估算，承载NB-IoT的终端模组基于电池的待机时间可达10年之久。模块成本的降低，也让市场更多的公司开始应用这项技术，风靡全国的共享单车就是其一。某公司第三代的智能锁就采用了NB-IoT的模组，一方面是运营商的大力推广，另一方面也确实带来了价值。</p><p>LoRa</p><p>与NB-IoT齐头并进发展的就是LoRa，与之不同的是LoRa技术使用非授权频段。它是由Semtech公司采用和推广的一种基于扩频技术的超远距离无线传输技术。LoRa全称是Long Range，顾名思义，LoRa可以支持长距离传输。在中国，LoRa可以使用的频段有两个：CN779-787以及CN470-CN510。由于CN779-787最大发射功率只有10dBm(10mW)，并没有“实用”的价值。所以人们更青睐于CN470-CN510这个频段，它的最大发射功率可以达到17dBm(50mW)。</p><p>类比于Wi-Fi联盟，LoRa也有对应的LoRa联盟，旨为共同建立标准和规范，LoRaWAN就是这样的产物。</p><p><img src="http://www.elecfans.com/uploads/allimg/180416/0Q6021318_0.png" alt=""></p><p>LoRa与NB-IoT对比</p><p>基于成本的考虑，LoRa的模组单价在8-10美元左右，而且非授权频段也不需要支付额外的频谱成本，相比于NB-IoT而言，成本方面具有较大优势。在电池性能方面，由于NB-IoT在蜂窝授权频谱上工作，所以需要定时进行网络同步，会消耗相应的电量，而LoRa则无此担忧，但NB-IoT的这个特性也受到共享单车的热烈欢迎，可以基于此来做车辆的实时定位工作。另外，从商业模式上来看，NB-IoT属于运营商建网，业务方不需要自己来考虑基站的部署，比较省心;但与此同时，网络的质量、安全都是不可控的风险，且企业自身的增值也会受到一定阻碍。反观LoRa，属于企业自建网络，基站需自己部署，后续需自己运维、优化等，覆盖的点位、网络质量及安全等维度都要自己负责。</p><p>截止目前，没有哪个物联网技术能够成为真正的主流，对技术本身而言，没有绝对的完美;从业务出发，更是需要结合业务特点、商业模式去选择更适合的物联网技术。</p><p>物联网技术的发展伴随各方“豪杰”群雄逐鹿，未来会不会三足鼎立或由新的势力一统天下，让我们拭目以待。</p><p>以上是关于物联网中-物联网通信协议纷争：群雄逐鹿 百家争鸣的相关介绍，如果想要了解更多相关信息，请多多关注eeworld，eeworld电子工程将给大家提供更全、更详细、更新的资讯信息。</p><p>Stay hungry，Stay foolish！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://img.hacpai.com/bing/20180612.jpg?imageView2/1/w/960/h/520/interlace/1/q/100&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;整体结构&lt;/p&gt;
&lt;p&gt;物联网大体上有 3 个构成要素
      
    
    </summary>
    
      <category term="物联网" scheme="http://yoursite.com/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="物联网" scheme="http://yoursite.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>常见数据结构</title>
    <link href="http://yoursite.com/2019/02/22/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/02/22/常见数据结构/</id>
    <published>2019-02-22T02:58:58.000Z</published>
    <updated>2019-02-22T03:42:05.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是数据结构"><a href="#1-什么是数据结构" class="headerlink" title="1. 什么是数据结构"></a>1. 什么是数据结构</h2><p><img src="https://i.loli.net/2019/02/14/5c651a306c0f4.jpg" alt="5c651a306c0f4"></p><pre><code>数据存储于计算机的内存中。内存如右图所示，形似排成1列的箱子，1个箱子里存储1个数据。</code></pre><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-001.png" alt=""></p><p><strong>数据存储于内存时，决定了数据顺序和位置关系的便是“数据结构”。</strong></p><h2 id="2-常用数据结构"><a href="#2-常用数据结构" class="headerlink" title="2. 常用数据结构"></a>2. 常用数据结构</h2><h3 id="2-1-链表"><a href="#2-1-链表" class="headerlink" title="2.1 链表"></a>2.1 链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链表是数据结构之一，其中的数据呈线性排列。在链表中，数据的添加和删除都较为方便，就是访问比较耗费时间</span><br></pre></td></tr></table></figure><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-002.png" alt=""></p><p><strong>这就是链表的概念图。Blue、Yellow、Red 这3个字符串作为数据被存储于链表中。每个数据都有1个“指针”，它指向下一个数据的内存地址。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-003.png" alt=""></p><p><strong>在链表中，数据一般都是分散存储于内存中的，无须存储在连续空间内。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-004.png" alt=""></p><p><strong>因为数据都是分散存储的，所以如果想要访问数据，只能从第1个数据开始，顺着指针的指向一一往下访问（这便是顺序访问）。比如，想要找到 Red 这一数据，就得从 Blue 开始访问。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-005.png" alt=""></p><p><strong>这之后，还要经过 Yellow，我们才能找到 Red。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-006.png" alt=""></p><p><strong>如果想要添加数据，只需要改变添加位置前后的指针指向就可以，非常简单。比如，在 Blue 和 Yellow 之间添加 Green。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-007.png" alt=""></p><p><strong>将 Blue 的指针指向的位置变成 Green，然后再把 Green 的指针指向 Yellow，数据的添加就大功告成了。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-008.png" alt=""></p><p><strong>数据的删除也一样，只要改变指针的指向就可以，比如删除 Yellow。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-009.png" alt=""></p><p><strong>这时，只需要把 Green 指针指向的位置从 Yellow 变成 Red，删除就完成了。虽然 Yellow 本身还存储在内存中，但是不管从哪里都无法访问这个数据，所以也就没有特意去删除它的必要了。今后需要用到 Yellow 所在的存储空间时，只要用新数据覆盖掉就可以了。</strong></p><blockquote><p><strong>补充说明</strong></p><p>上文中讲述的链表是最基本的一种链表。除此之外，还存在几种扩展方便的链表。</p><p>虽然上文中提到的链表在尾部没有指针，但我们也可以在链表尾部使用指针，并且让它指向链表头部的数据，将链表变成环形。这便是“循环链表”，也叫“环形链表”。循环链表没有头和尾的概念。想要保存数量固定的最新数据时通常会使用这种链表。</p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-010.png" alt=""></p><p>另外，上文链表里的每个数据都只有一个指针，但我们可以把指针设定为两个，并且让它们分别指向前后数据，这就是“双向链表”。使用这种链表，不仅可以从前往后，还可以从后往前遍历数据，十分方便。</p><p>但是，双向链表存在两个缺点：一是指针数的增加会导致存储空间需求增加；二是添加和删除数据时需要改变更多指针的指向。</p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-011.png" alt=""></p></blockquote><h3 id="2-2-数组"><a href="#2-2-数组" class="headerlink" title="2.2 数组"></a>2.2 数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组也是数据呈线性排列的一种数据结构。与前一节中的链表不同，在数组中，访问数据十分简单，而添加和删除数据比较耗工夫。</span><br></pre></td></tr></table></figure><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-012.png" alt=""></p><p><strong>这就是数组的概念图。Blue、Yellow、Red 作为数据存储在数组中。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-013.png" alt=""></p><p><strong>数据按顺序存储在内存的连续空间内。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-014.png" alt=""></p><p><strong>由于数据是存储在连续空间内的，所以每个数据的内存地址（在内存上的位置）都可以通过数组下标算出，我们也就可以借此直接访问目标数据（这叫作“随机访问”）。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-015.png" alt=""></p><p><strong>比如现在我们想要访问 Red。如果使用指针就只能从头开始查找，但在数组中，只需要指定<img src="http://private.codecogs.com/gif.latex?a[2]" alt="a[2]">，便能直接访问 Red。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-016.png" alt=""></p><p><strong>但是，如果想在任意位置上添加或者删除数据，数组的操作就要比链表复杂多了。这里我们尝试将 Green 添加到第2个位置上。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-017.png" alt=""></p><p><strong>首先，在数组的末尾确保需要增加的存储空间。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-018.png" alt=""></p><p><strong>为了给新数据腾出位置，要把已有数据一个个移开。首先把 Red 往后移。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-019.png" alt=""></p><p><strong>然后把 Yellow 往后移。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-020.png" alt=""></p><p><strong>最后在空出来的位置上写入 Green。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-021.png" alt=""></p><p><strong>添加数据的操作就完成了。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-022.png" alt=""></p><p><strong>反过来，如果想要删除 Green……</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-023.png" alt=""></p><p><strong>首先，删掉目标数据（在这里指 Green）。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-024.png" alt=""></p><p><strong>然后把后面的数据一个个往空位移。先把 Yellow 往前移。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-025.png" alt=""></p><p><strong>接下来移动 Red。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-026.png" alt=""></p><p><strong>最后再删掉多余的空间。这样一来 Green 便被删掉了。</strong></p><blockquote><p><strong>补充说明</strong></p><p>在链表和数组中，数据都是线性地排成一列。在链表中访问数据较为复杂，添加和删除数据较为简单；而在数组中访问数据比较简单，添加和删除数据却比较复杂。</p><p>我们可以根据哪种操作较为频繁来决定使用哪种数据结构。</p><table><thead><tr><th></th><th>访问</th><th>添加</th><th>删除</th></tr></thead><tbody><tr><td>链表</td><td>慢</td><td>快</td><td>快</td></tr><tr><td>数组</td><td>快</td><td>慢</td><td>慢</td></tr></tbody></table></blockquote><h3 id="2-3-栈"><a href="#2-3-栈" class="headerlink" title="2.3 栈"></a>2.3 栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈也是一种数据呈线性排列的数据结构，不过在这种结构中，我们只能访问最新添加的数据。栈就像是一摞书，拿到新书时我们会把它放在书堆的最上面，取书时也只能从最上面的新书开始取。</span><br></pre></td></tr></table></figure><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-027.png" alt=""></p><p><strong>这就是栈的概念图。现在存储在栈中的只有数据 Blue。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-028.png" alt=""></p><p><strong>然后，栈中添加了数据 Green。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-029.png" alt=""></p><p><strong>接下来，数据 Red 入栈。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-030.png" alt=""></p><p><strong>从栈中取出数据时，是从最上面，也就是最新的数据开始取出的。这里取出的是 Red。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-031.png" alt=""></p><p><strong>如果再进行一次出栈操作，取出的就是 Green 了。</strong></p><blockquote><p><strong>解说</strong></p><p>像栈这种最后添加的数据最先被取出，即“后进先出”的结构，我们称为 Last In First Out，简称 LIFO。</p><p>与链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行。</p><p><strong>应用示例</strong></p><p>栈只能在一端操作这一点看起来似乎十分不便，但在只需要访问最新数据时，使用它就比较方便了。</p><p>比如，规定（AB（C（DE）F）（G（（H）I J）K））这一串字符中括号的处理方式如下：首先从左边开始读取字符，读到左括号就将其入栈，读到右括号就将栈顶的左括号出栈。此时，出栈的左括号便与当前读取的右括号相匹配。通过这种处理方式，我们就能得知配对括号的具体位置。</p></blockquote><h3 id="2-4-队列"><a href="#2-4-队列" class="headerlink" title="2.4 队列"></a>2.4 队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与前面提到的数据结构相同，队列中的数据也呈线性排列。虽然与栈有些相似，但队列中添加和删除数据的操作分别是在两端进行的。就和“队列”这个名字一样，把它想象成排成一队的人更容易理解。在队列中，处理总是从第一名开始往后进行，而新来的人只能排在队尾。</span><br></pre></td></tr></table></figure><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-032.png" alt=""></p><p><strong>这就是队列的概念图。现在队列中只有数据 Blue。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-033.png" alt=""></p><p><strong>然后，队列中添加了数据 Green。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-034.png" alt=""></p><p><strong>紧接着，数据 Red 也入队了。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-035.png" alt=""></p><p><strong>从队列中取出（删除）数据时，是从最下面，也就是最早入队的数据开始的。这里取出的是 Blue。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-036.png" alt=""></p><p><strong>如果再进行一次出队操作，取出的就是 Green 了。</strong></p><blockquote><p><strong>解说</strong></p><p>像队列这种最先进去的数据最先被取来，即“先进先出”的结构，我们称为 First In First Out，简称 FIFO。</p><p>与栈类似，队列中可以操作数据的位置也有一定的限制。在栈中，数据的添加和删除都在同一端进行，而在队列中则分别是在两端进行的。队列也不能直接访问位于中间的数据，必须通过出队操作将目标数据变成首位后才能访问。</p></blockquote><h3 id="2-5-哈希表"><a href="#2-5-哈希表" class="headerlink" title="2.5 哈希表"></a>2.5 哈希表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在哈希表这种数据结构中，使用将在5-3节讲解的“哈希函数”，可以使数据的查询效率得到显著提升。</span><br></pre></td></tr></table></figure><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-037.png" alt=""></p><p><strong>哈希表存储的是由键（key）和值（value）组成的数据。例如，我们将每个人的性别作为数据进行存储，键为人名，值为对应的性别。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-038.png" alt=""></p><p><strong>为了和哈希表进行对比，我们先将这些数据存储在数组中。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-039.png" alt=""></p><p><strong>此处准备了6个箱子（即长度为6的数组）来存储数据。假设我们需要查询 Ally 的性别，由于不知道 Ally 的数据存储在哪个箱子里，所以只能从头开始查询。这个操作便叫作“线性查找”。</strong></p><blockquote><p><strong>提示</strong>　一般来说，我们可以把键当成数据的标识符，把值当成数据的内容。</p></blockquote><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-040.png" alt=""></p><p><strong>0号箱子中存储的键是 Joe 而不是 Ally。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-041.png" alt=""></p><p><strong>1号箱子中的也不是 Ally。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-042.png" alt=""></p><p><strong>同样，2号、3号箱子中的也都不是 Ally。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-043.png" alt=""></p><p><strong>查找到4号箱子的时候，发现其中数据的键为 Ally。把键对应的值取出，我们就知道 Ally 的性别为女（F）了。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-044.png" alt=""></p><p><strong>数据量越多，线性查找耗费的时间就越长。由此可知：由于数据的查询较为耗时，所以此处并不适合使用数组来存储数据。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-045.png" alt=""></p><p><strong>但使用哈希表便可以解决这个问题。首先准备好数组，这次我们用5个箱子的数组来存储数据。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-046.png" alt=""></p><p><strong>尝试把 Joe 存进去。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-047.png" alt=""></p><p><strong>使用哈希函数（Hash）计算 Joe 的键，也就是字符串“Joe”的哈希值。得到的结果为4928。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-048.png" alt=""></p><p><strong>将得到的哈希值除以数组的长度5，求得其余数。这样的求余运算叫作“mod 运算”。此处 mod 运算的结果为3。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-049.png" alt=""></p><p><strong>因此，我们将 Joe 的数据存进数组的3号箱子中。重复前面的操作，将其他数据也存进数组中。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-050.png" alt=""></p><p><strong>Sue 键的哈希值为7291，mod 5的结果为1，将 Sue 的数据存进1号箱中。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-051.png" alt=""></p><p><strong>Dan 键的哈希值为1539，mod 5的结果为4，将 Dan 的数据存进4号箱中。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-052.png" alt=""></p><p><strong>Nell 键的哈希值为6276，mod 5的结果为1。本应将其存进数组的1号箱中，但此时1号箱中已经存储了 Sue 的数据。这种存储位置重复了的情况便叫作“冲突”。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-053.png" alt=""></p><p><strong>遇到这种情况，可使用链表在已有数据的后面继续存储新的数据。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-054.png" alt=""></p><p><strong>Ally 键的哈希值为9143，mod 5的结果为3。本应将其存储在数组的3号箱中，但3号箱中已经有了 Joe 的数据，所以使用链表，在其后面存储 Ally 的数据。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-055.png" alt=""></p><p><strong>Bob 键的哈希值为5278，mod 5的结果为3。本应将其存储在数组的3号箱中，但3号箱中已经有了 Joe 和 Ally 的数据，所以使用链表，在 Ally 的后面继续存储 Bob 的数据。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-056.png" alt=""></p><p><strong>像这样存储完所有数据，哈希表也就制作完成了。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-057.png" alt=""></p><p><strong>接下来讲解数据的查询方法。假设我们要查询 Dan 的性别。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-058.png" alt="{55%}"></p><p><strong>为了知道 Dan 存储在哪个箱子里，首先需要算出 Dan 键的哈希值，然后对其进行 mod 运算。最后得到的结果为4，于是我们知道了它存储在4号箱中。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-059.png" alt=""></p><p><strong>查看4号箱可知，其中的数据的键与 Dan 一致，于是取出对应的值。由此我们便知道了 Dan 的性别为男（M）。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-060.png" alt=""></p><p><strong>那么，想要查询 Ally 的性别时该怎么做呢？为了找到它的存储位置，先要算出 Ally 键的哈希值，再对其进行 mod 运算。最终得到的结果为3。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-061.png" alt=""></p><p><strong>然而3号箱中数据的键是 Joe 而不是 Ally。此时便需要对 Joe 所在的链表进行线性查找。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-062.png" alt=""></p><p><strong>于是我们找到了键为 Ally 的数据。取出其对应的值，便知道了 Ally 的性别为女（F）。</strong></p><blockquote><p><strong>解说</strong></p><p>在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用链表进行存储。这样一来，不管数据量为多少，我们都能够灵活应对。</p><p>如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。因此，给数组设定合适的空间非常重要。</p><p><strong>补充说明</strong></p><p>在存储数据的过程中，如果发生冲突，可以利用链表在已有数据的后面插入新数据来解决冲突。这种方法被称为“链地址法”。</p><p>除了链地址法以外，还有几种解决冲突的方法。其中，应用较为广泛的是“开放地址法”。这种方法是指当冲突发生时，立刻计算出一个候补地址（数组上的位置）并将数据存进去。如果仍然有冲突，便继续计算下一个候补地址，直到有空地址为止。可以通过多次使用哈希函数或“线性探测法”等方法计算候补地址。</p></blockquote><h3 id="2-6-堆"><a href="#2-6-堆" class="headerlink" title="2.6 堆"></a>2.6 堆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">堆是一种图的树形结构，被用于实现“优先队列”（priority queues）优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。在堆的树形结构中，各个顶点被称为“结点”（node），数据就存储在这些结点中。</span><br></pre></td></tr></table></figure><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-063.png" alt=""></p><p><strong>这就是堆的示例。结点内的数字就是存储的数据。堆中的每个结点最多有两个子结点。树的形状取决于数据的个数。另外，结点的排列顺序为从上到下，同一行里则为从左到右。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-064.png" alt=""></p><p><strong>在堆中存储数据时必须遵守这样一条规则：子结点必定大于父结点。因此，最小值被存储在顶端的根结点中。往堆中添加数据时，为了遵守这条规则，一般会把新数据放在最下面一行靠左的位置。当最下面一行里没有多余空间时，就再往下另起一行，把数据加在这一行的最左端。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-065.png" alt=""></p><p><strong>我们试试往堆里添加数字5。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-066.png" alt=""></p><p><strong>首先按照02的说明寻找新数据的位置。该图中最下面一排空着一个位置，所以将数据加在此处。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-067.png" alt=""></p><p><strong>如果父结点大于子结点，则不符合上文提到的规则，因此需要交换父子结点的位置。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-068.png" alt=""></p><p><strong>这里由于父结点的6大于子结点的5，所以交换了这两个数字。重复这样的操作直到数据都符合规则，不再需要交换为止。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-069.png" alt=""></p><p><strong>现在，父结点的1小于子结点的5，父结点的数字更小，所以不再交换。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-070.png" alt=""></p><p><strong>这样，往堆中添加数据的操作就完成了。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-071.png" alt=""></p><p><strong>从堆中取出数据时，取出的是最上面的数据。这样，堆中就能始终保持最上面的数据最小。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-072.png" alt=""></p><p><strong>由于最上面的数据被取出，因此堆的结构也需要重新调整。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-073.png" alt=""></p><p><strong>按照<img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-108.png" alt="">中说明的排列顺序，将最后的数据（此处为6）移动到最顶端。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-074.png" alt=""></p><p><strong>如果子结点的数字小于父结点的，就将父结点与其左右两个子结点中较小的一个进行交换。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-075.png" alt=""></p><p><strong>这里由于父结点的6大于子结点（右）的5大于子结点（左）的3，所以将左边的子结点与父结点进行交换。重复这个操作直到数据都符合规则，不再需要交换为止。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-076.png" alt=""></p><p><strong>现在，子结点（右）的8大于父结点的6大于子结点（左）的4，需要将左边的子结点与父结点进行交换。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-077.png" alt=""></p><p><strong>这样，从堆中取出数据的操作便完成了。</strong></p><h3 id="2-7-二叉查找树"><a href="#2-7-二叉查找树" class="headerlink" title="2.7 二叉查找树"></a>2.7 二叉查找树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二叉查找树（又叫作二叉搜索树或二叉排序树）是一种数据结构，采用了图的树形结构）。数据存储于二叉查找树的各个结点中。</span><br></pre></td></tr></table></figure><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-078.png" alt=""></p><p><strong>这就是二叉查找树的示例。结点中的数字便是存储的数据。此处以不存在相同数字为前提进行说明。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-079.png" alt=""></p><p><strong>二叉查找树有两个性质。第一个是每个结点的值均大于其左子树上任意一个结点的值。比如结点9大于其左子树上的3和8。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-080.png" alt=""></p><p><strong>同样，结点15也大于其左子树上任意一个结点的值。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-081.png" alt=""></p><p><strong>第二个是每个结点的值均小于其右子树上任意一个结点的值。比如结点15小于其右子树上的23、17和28。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-082.png" alt=""></p><p><strong>根据这两个性质可以得到以下结论。首先，二叉查找树的最小结点要从顶端开始，往其左下的末端寻找。此处最小值为3。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-083.png" alt=""></p><p><strong>反过来，二叉查找树的最大结点要从顶端开始，往其右下的末端寻找。此处最大值为28。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-084.png" alt=""></p><p><strong>下面我们来试着往二叉查找树中添加数据。比如添加数字1。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-085.png" alt=""></p><p><strong>首先，从二叉查找树的顶端结点开始寻找添加数字的位置。将想要添加的1与该结点中的值进行比较，小于它则往左移，大于它则往右移。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-086.png" alt=""></p><p><strong>由于1&lt;9，所以将1往左移。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-087.png" alt=""></p><p><strong>由于1&lt;3，所以继续将1往左移，但前面已经没有结点了，所以把1作为新结点添加到左下方。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-088.png" alt=""></p><p><strong>这样，1的添加操作便完成了。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-089.png" alt=""></p><p><strong>接下来，我们再试试添加数字4。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-090.png" alt=""></p><p><strong>和前面的步骤一样，首先从二叉查找树的顶端结点开始寻找添加数字的位置。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-091.png" alt=""></p><p><strong>由于4&lt;9，所以将其往左移。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-092.png" alt=""></p><p><strong>由于4&gt;3，所以将其往右移。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-093.png" alt=""></p><p><strong>由于4&lt;8，所以需要将其往左移，但前面已经没有结点了，所以把4作为新结点添加到左下方。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-094.png" alt=""></p><p><strong>于是4的添加操作也完成了。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-095.png" alt=""></p><p><strong>接下来看看如何在二叉查找树中删除结点。比如我们来试试删除结点28。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-096.png" alt=""></p><p><strong>如果需要删除的结点没有子结点，直接删掉该结点即可。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-097.png" alt=""></p><p><strong>再试试删除结点8。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-098.png" alt=""></p><p><strong>如果需要删除的结点只有一个子结点，那么先删掉目标结点……</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-099.png" alt=""></p><p><strong>然后把子结点移到被删除结点的位置上即可。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-100.png" alt=""></p><p><strong>最后来试试删除结点9。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-101.png" alt=""></p><p><strong>如果需要删除的结点有两个子结点，那么先删掉目标结点……</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-102.png" alt=""></p><p><strong>然后在被删除结点的左子树中寻找最大结点……</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-103.png" alt=""></p><p><strong>最后将最大结点移到被删除结点的位置上。这样一来，就能在满足二叉查找树性质的前提下删除结点了。如果需要移动的结点（此处为4）还有子结点，就递归执行前面的操作。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-104.png" alt=""></p><p><strong>下面来看看如何在二叉查找树中查找结点。比如我们来试试查找12。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-105.png" alt=""></p><p><strong>从二叉查找树的顶端结点开始往下查找。和添加数据时一样，把12和结点中的值进行比较，小于该结点的值则往左移，大于则往右移。</strong></p><blockquote><p><strong>提示</strong>　删除9的时候，我们将“左子树中的最大结点”移动到了删除结点的位置上，但是根据二叉查找树的性质可知，移动“右子树中的最小结点”也没有问题。</p></blockquote><p><img src="https://images.gitbook.cn/508b18c0-1997-11e9-a0b8-bb857010c430" alt="enter image description here"></p><p><strong>由于12&gt;4，所以往右移。</strong></p><p><img src="http://www.ituring.com.cn/figures/2018/AlgorithmZukan/01-107.png" alt="s"></p><p><strong>找到结点12了。</strong></p><blockquote><p><strong>补充说明</strong></p><p>有很多以二叉查找树为基础扩展的数据结构，比如“平衡二叉查找树”。这种数据结构可以修正形状不均衡的树，让其始终保持均衡形态，以提高查找效率。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是数据结构&quot;&gt;&lt;a href=&quot;#1-什么是数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是数据结构&quot;&gt;&lt;/a&gt;1. 什么是数据结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/14/
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>通过nginx对tcp/udp进行负载均衡</title>
    <link href="http://yoursite.com/2019/02/22/%E9%80%9A%E8%BF%87nginx%E5%AF%B9tcp-udp%E8%BF%9B%E8%A1%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2019/02/22/通过nginx对tcp-udp进行负载均衡/</id>
    <published>2019-02-22T02:54:50.000Z</published>
    <updated>2019-02-22T03:08:18.585Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1. 安装nginx"></a>1. 安装nginx</h3><h4 id="1-1-通过yum安装"><a href="#1-1-通过yum安装" class="headerlink" title="1.1 通过yum安装"></a>1.1 通过yum安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@yaoxiang ~]# yum install nginx</span><br></pre></td></tr></table></figure><h4 id="1-2-查看nginx的版本"><a href="#1-2-查看nginx的版本" class="headerlink" title="1.2 查看nginx的版本"></a>1.2 查看nginx的版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@yaoxiang ~]# nginx -v</span><br><span class="line">nginx version: nginx/1.12.2</span><br></pre></td></tr></table></figure><p>nginx的版本必须高于1.9.0，因为从1.9开始nginx就支持对TCP的转发，而到了1.9.13时，UDP转发也支持了。</p><h4 id="1-3-查看默认编译参数"><a href="#1-3-查看默认编译参数" class="headerlink" title="1.3 查看默认编译参数"></a>1.3 查看默认编译参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@yaoxiang ~]# nginx -V</span><br><span class="line">nginx version: nginx/1.12.2</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC) </span><br><span class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/var/lib/nginx/tmp/client_body --http-proxy-temp-path=/var/lib/nginx/tmp/proxy --http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi --http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi --http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid --lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-file-aio --with-ipv6 --with-http_auth_request_module --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_addition_module --with-http_xslt_module=dynamic --with-http_image_filter_module=dynamic --with-http_geoip_module=dynamic --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-http_perl_module=dynamic --with-mail=dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-google_perftools_module --with-debug --with-cc-opt=&apos;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&apos; --with-ld-opt=&apos;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&apos;</span><br></pre></td></tr></table></figure><p>nginx实现TCP/UDP的转发依靠的是<strong>Stream</strong>模块，查看默认编译参数中是含有<strong>–with-stream</strong>参数，可以看到上面的参数里含有<strong>–with-stream=dynamic</strong>,说明已动态加载Stream模块</p><h3 id="2-修改nginx配置"><a href="#2-修改nginx配置" class="headerlink" title="2. 修改nginx配置"></a>2. 修改nginx配置</h3><h4 id="2-1-增加stream块"><a href="#2-1-增加stream块" class="headerlink" title="2.1 增加stream块"></a>2.1 增加stream块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@yaoxiang ~]# vim /etc/nginx/nginx.conf</span><br><span class="line">...</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">stream &#123;</span><br><span class="line">#定义被代理的服务器组upstream 组名</span><br><span class="line">upstream dns &#123;</span><br><span class="line"> # zone   dns 64k;</span><br><span class="line">  server 172.27.9.204:4005;#代理的服务器地址</span><br><span class="line">  server 172.27.9.204:4006 weight=5;#weight 权重，默认都是1</span><br><span class="line">  server 172.27.9.204:4007 max_fails=3 fail_timeout=30s;#max_fails - NGINX将服务器标记为不可用的连续失败尝试次数。fail_timeout为NGINX认为服务器不可用的时间长度。</span><br><span class="line">  server 172.27.9.204:4008 backup;#backup 备用服务器，其他服务器不可用时，才会收到转发</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 4000 udp;#监听udp4000端口，如不加udp则默认监听tcp</span><br><span class="line"></span><br><span class="line">  proxy_responses 1;#1代表需要回应，并将回应转发；0代表不需要回应</span><br><span class="line"></span><br><span class="line">  proxy_timeout 20s;#回应超时时间，超时未回应暂停转发</span><br><span class="line"></span><br><span class="line">  proxy_pass dns;#代理服务器、服务器组</span><br><span class="line"></span><br><span class="line">  proxy_buffer_size 512k;#响应缓冲区大小，如果后端发送的响应头过大可以尝试增加此缓冲。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-负载均衡策略"><a href="#2-2-负载均衡策略" class="headerlink" title="2.2 负载均衡策略"></a>2.2 负载均衡策略</h4><ul><li><p>round-robin（轮询）——默认，Nginx使用轮询算法负载均衡通信。因为是默认方法，所以没有round-robin指令；只创建upstream配置块在顶级stream上下文并像之前步骤添加server指令。</p></li><li><p>last_conn（最少连接）——Nginx选择当前活跃连接数较少的服务器。</p></li><li><p>least_tome——Nginx选择最低平均延迟和最少活跃连接的服务器。最低活跃连接基于least_time指令的以下参数计算：</p><ul><li><p>connect——连接upstream服务器的时间</p></li><li><p>first_byte——接收第一个数据字节的时间</p></li><li><p>last_byte——从服务器接收完整响应的时间</p></li></ul></li><li><p>hash——Nginx基于用户定义键选择服务器，例如，源IP地址</p></li></ul><p>#####例子：采用最少连接和hash负载均衡策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream dns &#123;</span><br><span class="line"> last_conn;#最少连接策略</span><br><span class="line"> server 172.27.9.204:4005;#代理的服务器地址</span><br><span class="line"> server 172.27.9.204:4006;</span><br><span class="line"> server 172.27.9.204:4007;</span><br><span class="line"> server 172.27.9.204:4008;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">upstream stream_backend &#123;</span><br><span class="line"></span><br><span class="line">    hash $remote_addr;</span><br><span class="line"></span><br><span class="line">    server backend1.example.com:12345;</span><br><span class="line"></span><br><span class="line">    server backend2.example.com:12345;</span><br><span class="line"></span><br><span class="line">    server backend3.example.com:12346;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-启动nginx"><a href="#3-启动nginx" class="headerlink" title="3.启动nginx"></a>3.启动nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@yaoxiang nginx]# sudo nginx</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br></pre></td></tr></table></figure><p>出现以上提示说明端口被占用，修改nginx.conf里http模块中的端口号</p><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h3><h4 id="4-1-向nginx主机发送报文"><a href="#4-1-向nginx主机发送报文" class="headerlink" title="4.1 向nginx主机发送报文"></a>4.1 向nginx主机发送报文</h4><p><img src="https://i.loli.net/2019/02/20/5c6cc58eca105.png" alt="5c6cc58eca105"></p><h4 id="4-2-可以看到代理服务器组主机的不同端口都接收到了"><a href="#4-2-可以看到代理服务器组主机的不同端口都接收到了" class="headerlink" title="4.2 可以看到代理服务器组主机的不同端口都接收到了"></a>4.2 可以看到代理服务器组主机的不同端口都接收到了</h4><p><strong>4006端口</strong></p><p><img src="https://i.loli.net/2019/02/20/5c6cc5f85088e.png" alt="*5c6cc5f85088e*"></p><p><strong>4005端口</strong></p><p><img src="https://i.loli.net/2019/02/20/5c6cc63f11161.png" alt="5c6cc63f11161"></p><h4 id="4-3-接收端代理服务器向nginx主机回复消息"><a href="#4-3-接收端代理服务器向nginx主机回复消息" class="headerlink" title="4.3 接收端代理服务器向nginx主机回复消息"></a>4.3 接收端代理服务器向nginx主机回复消息</h4><p><img src="https://i.loli.net/2019/02/20/5c6cc6d772438.png" alt="5c6cc6d772438"></p><h4 id="4-4-可以看到发送端收到了回复"><a href="#4-4-可以看到发送端收到了回复" class="headerlink" title="4.4 可以看到发送端收到了回复"></a>4.4 可以看到发送端收到了回复</h4><p><img src="https://i.loli.net/2019/02/20/5c6cc7812a6dc.png" alt="5c6cc7812a6dc"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装nginx&quot;&gt;&lt;a href=&quot;#1-安装nginx&quot; class=&quot;headerlink&quot; title=&quot;1. 安装nginx&quot;&gt;&lt;/a&gt;1. 安装nginx&lt;/h3&gt;&lt;h4 id=&quot;1-1-通过yum安装&quot;&gt;&lt;a href=&quot;#1-1-通过yum安装&quot;
      
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>tomcat项目去除工程名访问</title>
    <link href="http://yoursite.com/2018/12/12/tomcat%E9%A1%B9%E7%9B%AE%E5%8E%BB%E9%99%A4%E5%B7%A5%E7%A8%8B%E5%90%8D%E8%AE%BF%E9%97%AE/"/>
    <id>http://yoursite.com/2018/12/12/tomcat项目去除工程名访问/</id>
    <published>2018-12-12T15:30:04.000Z</published>
    <updated>2018-12-13T14:11:23.500Z</updated>
    
    <content type="html"><![CDATA[<h4 id="修改tomcat配置文件"><a href="#修改tomcat配置文件" class="headerlink" title="修改tomcat配置文件"></a>修改tomcat配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@4e198f488545:/usr/local/tomcat# vim conf/server.xml</span><br></pre></td></tr></table></figure><h4 id="增加下面一行"><a href="#增加下面一行" class="headerlink" title="增加下面一行"></a>增加下面一行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context  path=&quot;/&quot;  docBase=&quot;/usr/local/tomcat/webapps/solo/&quot;  reloadable=&quot;true&quot;  crossContext=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure><p>docBase为项目根目录</p><h4 id="重启tomcat即可。"><a href="#重启tomcat即可。" class="headerlink" title="重启tomcat即可。"></a>重启tomcat即可。</h4><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;修改tomcat配置文件&quot;&gt;&lt;a href=&quot;#修改tomcat配置文件&quot; class=&quot;headerlink&quot; title=&quot;修改tomcat配置文件&quot;&gt;&lt;/a&gt;修改tomcat配置文件&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;root@4e198f488545:/usr/local/tomcat# vim conf/server.xml&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;增加下面一行&quot;&gt;&lt;a href=&quot;#增加下面一行&quot; class=&quot;headerlink&quot; title=&quot;增加下面一行&quot;&gt;&lt;/a&gt;增加下面一行&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Context  path=&amp;quot;/&amp;quot;  docBase=&amp;quot;/usr/local/tomcat/webapps/solo/&amp;quot;  reloadable=&amp;quot;true&amp;quot;  crossContext=&amp;quot;true&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;docBase为项目根目录&lt;/p&gt;
&lt;h4 id=&quot;重启tomcat即可。&quot;&gt;&lt;a href=&quot;#重启tomcat即可。&quot; class=&quot;headerlink&quot; title=&quot;重启tomcat即可。&quot;&gt;&lt;/a&gt;重启tomcat即可。&lt;/h4&gt;
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="tomcat" scheme="http://yoursite.com/tags/tomcat/"/>
    
  </entry>
  
</feed>
